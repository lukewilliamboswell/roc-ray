use std::env;
use std::fs;
use std::io::{self, Cursor};
use std::path::Path;

#[cfg(target_os = "macos")]
fn main() {
    // Re-run this build script if roc rebuild's the app
    println!("cargo:rerun-if-changed=app.o");

    // Check if the app.o file exists
    if !Path::new("app.o").exists() {
        panic!("app.o file not found -- this should have been generated by roc");
    }

    // Get the build cache directory (OUT_DIR)
    let out_dir = env::var("OUT_DIR").unwrap();

    // Search for static libraries in the cache directory
    println!("cargo:rustc-link-search=native={out_dir}");

    // Run the `libtool -static -o libapp.a app.o` command
    // to create a static library from the object file
    let lib_app_path = Path::new(&out_dir).join("libapp.a");
    let output = std::process::Command::new("libtool")
        .args(&[
            "-static",
            "-o",
            format!("{}", lib_app_path.into_os_string().into_string().unwrap()).as_str(),
            "app.o",
        ])
        .output()
        .expect("Failed to execute libtool command");

    if !output.status.success() {
        panic!("libtool command failed with status: {}", output.status);
    }

    let out_path = Path::new(&out_dir).join("libraylib.a");

    // Download the raylib release and extract the static library
    download_raylib_release(
        "https://github.com/raysan5/raylib/releases/download/5.0/raylib-5.0_macos.tar.gz",
        "raylib-5.0_macos/lib/libraylib.a",
        &out_path,
    )
    .unwrap();

    // Static link the app and raylib libraries, and dynamic link the required Macos frameworks
    println!("cargo:rustc-link-lib=static=app");
    println!("cargo:rustc-link-lib=static=raylib");
    println!("cargo:rustc-link-lib=framework=CoreFoundation");
    println!("cargo:rustc-link-lib=framework=CoreGraphics");
    println!("cargo:rustc-link-lib=framework=IOKit");
    println!("cargo:rustc-link-lib=framework=AppKit");
    println!("cargo:rustc-link-lib=framework=Foundation");
}

#[cfg(target_os = "linux")]
fn main() {
    println!("cargo:rerun-if-changed=app.o");

    // Run the `ar rcs libapp.a app.o` command
    let output = std::process::Command::new("ar")
        .args(&["rcs", "libapp.a", "app.o"])
        .output()
        .expect("Failed to execute ar command");

    if !output.status.success() {
        panic!("ar command failed with status: {}", output.status);
    }

    download_raylib_release(
        "https://github.com/raysan5/raylib/releases/download/5.0/raylib-5.0_linux_amd64.tar.gz",
        "raylib-5.0_linux_amd64/lib/libraylib.a",
    )
    .unwrap();

    println!("cargo:rustc-link-lib=static=app");
}

#[cfg(target_os = "windows")]
fn main() {
    println!("cargo:rerun-if-changed=app.lib");
    println!("cargo:rustc-link-lib=static=app");

    download_raylib_release(
        "https://github.com/raysan5/raylib/releases/download/5.0/raylib-5.0_win64_mingw-w64.zip",
        "raylib-5.0_win64_mingw-w64/lib/libraylib.a",
    )
    .unwrap();
}

fn download_raylib_release(
    url: &str,
    sub_path: &str,
    out_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    // Check if the file already exists to avoid re-downloading
    if out_path.exists() {
        println!("cargo:rerun-if-changed={}", out_path.display());
        return Ok(());
    }

    let response = reqwest::blocking::get(url)?;
    let bytes = response.bytes()?;

    #[cfg(not(target_os = "windows"))]
    {
        extract_tarball(bytes, sub_path, &out_path)?;
    }

    #[cfg(target_os = "windows")]
    {
        extract_zip(bytes, sub_path, &out_path)?;
    }

    // Check if the file was extracted successfully
    if !out_path.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            format!("libraylib.a not found in the archive downloaded from {url}"),
        )
        .into());
    }

    Ok(())
}

#[cfg(not(target_os = "windows"))]
fn extract_tarball(
    bytes: bytes::Bytes,
    sub_path: &str,
    out_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let tar = flate2::read::GzDecoder::new(Cursor::new(bytes));
    let mut archive = tar::Archive::new(tar);

    for entry in archive.entries()? {
        let mut entry = entry?;
        if let Ok(path) = entry.path() {
            if path == Path::new(sub_path) {
                if let Some(parent) = out_path.parent() {
                    fs::create_dir_all(parent)?;
                }
                entry.unpack(&out_path)?;
                break;
            }
        }
    }
    Ok(())
}

#[cfg(target_os = "windows")]
fn extract_zip(
    bytes: bytes::Bytes,
    sub_path: &str,
    out_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut archive = zip::ZipArchive::new(Cursor::new(bytes))?;

    for i in 0..archive.len() {
        let mut file = archive.by_index(i)?;
        if file.name() == sub_path {
            if let Some(parent) = out_path.parent() {
                fs::create_dir_all(parent)?;
            }
            let mut out_file = fs::File::create(&out_path)?;
            io::copy(&mut file, &mut out_file)?;
            break;
        }
    }
    Ok(())
}
